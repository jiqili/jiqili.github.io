---
title: Chrome扩展开发小试
tags: [Extension]
---

# 前言
最近有个需求是为一个知识库项目做一个Chrome扩展，方便用户爬取加载到本地浏览器的文本内容以及特定网站的视频字幕文件，然后发送到localhost。
项目中有个桌面端的悬浮工具球作为知识库的客户端，这个客户端提供了本地网络接口。于是我尝试了一下Chrome扩展的开发，发现其实并不复杂。

# 插件的结构
一个Chrome扩展主要由以下几个部分组成：
- `manifest.json`：清单文件，定义扩展的基本信息和权限。当前最新版本是Manifest V3。

如果没有注册权限，那浏览器对象是不包含某些属性的。比如没有`notifications`权限，那么`chrome.notifications`会提示空属性。
我这个小项目用到了`["activeTab", "tabs", "notifications", "webRequest", "webNavigation", "nativeMessaging"]`
除了通知，还有监控网络请求，监听路由变化和标签页变化。我还尝试了和本地应用通信的`nativeMessaging`，不过后来换成了本地应用起一个HTTP服务器来通信，下文会详细说这个`nativeMessaging`。

另外还可以配置插件针对哪些url生效，可以用通配符。

Manifest V3里的background脚本需要用service worker来实现，不能再用之前的持久化脚本了，大模型告诉我V2版本可以让background脚本一直运行。
而service worker会被浏览器按需启动和关闭，那websocket估计就比较难搞了。

- `background.js`：后台脚本，处理扩展的核心逻辑。

这里相当于node环境，没有跨域问题。而且是单独的进程，和网页内容是隔离的。我们在这里监控网络请求，发消息，和`content.js`通信，监听路由变化和标签页变化。

- `content.js`：内容脚本，注入到网页中，获取网页内容，可以获取Dom。

这里有个关于iframe的问题，很多DOM树里都嵌入里iframe,而iframe里可能是跨域的网页，这样content script就无法访问iframe里的内容。只有同源的iframe才能用JavaScript访问。

- `popup.html`：弹出页面，用户点击扩展图标时显示的界面。

本项目没有做弹窗，由于需求比较简单，点击扩展图标后就开始爬取内容然后发送了。

# nativeMessaging
也是折腾了这玩意，还涉及到里Windows的注册表。首先它是通过`stdio`的方式和本地应用通信的。相当于插件进程起里一个子进程通信。所以发一次消息就要启动一个本地应用。

它的流程是先在windows注册表里的Local Machine里的谷歌目录下注册一个key，指定一个json文件的位置，这个json文件里指定了本地应用的路径和参数。如果桌面应用是你自己开发的，你可以在桌面应用的代码里完成这件事。
然后在扩展的manifest里声明`"nativeMessaging"`权限，就可以通过`chrome.runtime.sendNativeMessage`来发送消息了。这个函数的参数有一个注册表里注册好的key,首先找到对应的default value,这个value就是json文件的路径。
然后读取这个json文件，找到本地应用的路径，然后启动这个应用，并通过stdio和它通信。

这太麻烦里，还不如本地应用里启动里一个http服务。我看到谷歌目录下有其他软件的key,比如oneDrive。不过没有继续深入下去了，因为http服务很简单，就是多占一个网络端口。
